name: Deploy to EC2

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install Flask SQLAlchemy WTForms
    
    - name: Run basic tests
      run: |
        python -c "
        try:
            import flask, sqlalchemy, wtforms
            print('‚úÖ All core dependencies imported successfully')
            
            # Test basic Flask app creation
            from flask import Flask
            app = Flask(__name__)
            print('‚úÖ Flask app creation test passed')
            
            # Test SQLAlchemy import
            from sqlalchemy import create_engine
            print('‚úÖ SQLAlchemy import test passed')
            
            print('‚úÖ All tests passed successfully!')
            
        except ImportError as e:
            print(f'‚ùå Import error: {e}')
            exit(1)
        except Exception as e:
            print(f'‚ùå Test error: {e}')
            exit(1)
        "

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy to EC2
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        port: 22
        command_timeout: 15m
        timeout: 60s
        script: |
          # First, ensure all required software is installed
          echo "üîß Setting up required software..."
          
          # Detect OS and set package manager
          if command -v apt &> /dev/null; then
            PKG_MANAGER="apt"
            UPDATE_CMD="sudo apt update -y"
            INSTALL_CMD="sudo apt install -y"
          elif command -v yum &> /dev/null; then
            PKG_MANAGER="yum"
            UPDATE_CMD="sudo yum update -y"
            INSTALL_CMD="sudo yum install -y"
          elif command -v dnf &> /dev/null; then
            PKG_MANAGER="dnf"
            UPDATE_CMD="sudo dnf update -y"
            INSTALL_CMD="sudo dnf install -y"
          else
            echo "‚ùå Unsupported package manager. Please install Git and Docker manually."
            exit 1
          fi
          
          echo "üìã Detected package manager: $PKG_MANAGER"
          
          # Update system
          echo "üîÑ Updating system packages..."
          $UPDATE_CMD
          
          # Install Git if not present
          if ! command -v git &> /dev/null; then
            echo "üì¶ Installing Git..."
            $INSTALL_CMD git
          else
            echo "‚úÖ Git is already installed"
          fi
          
          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            echo "üê≥ Installing Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh
            sudo usermod -aG docker $USER
            rm get-docker.sh
            echo "‚úÖ Docker installed successfully"
          else
            echo "‚úÖ Docker is already installed"
          fi
          
          # Install Docker Compose if not present
          if ! command -v docker-compose &> /dev/null; then
            echo "üîß Installing Docker Compose..."
            if [ "$PKG_MANAGER" = "apt" ]; then
              $INSTALL_CMD docker-compose
            else
              # For RHEL/CentOS/Amazon Linux, use direct download method to avoid pip conflicts
              echo "üì• Downloading Docker Compose binary..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
            fi
            echo "‚úÖ Docker Compose installed successfully"
          else
            echo "‚úÖ Docker Compose is already installed"
          fi
          
          # Verify docker-compose is accessible
          if ! command -v docker-compose &> /dev/null; then
            echo "‚ö†Ô∏è Docker Compose not found in PATH, trying alternative methods..."
            # Try to find docker-compose and create symlink
            COMPOSE_PATH=$(find /usr/local /home/${{ secrets.EC2_USERNAME }}/.local -name "docker-compose" -type f 2>/dev/null | head -1)
            if [ -n "$COMPOSE_PATH" ]; then
              echo "üìç Found Docker Compose at: $COMPOSE_PATH"
              sudo ln -sf "$COMPOSE_PATH" /usr/bin/docker-compose
              echo "‚úÖ Created symlink for Docker Compose"
            else
              echo "‚ùå Could not locate Docker Compose installation"
              exit 1
            fi
          fi
          
          # Ensure Docker service is running
          echo "üîÑ Starting Docker service..."
          sudo systemctl start docker
          sudo systemctl enable docker
          
          # Add user to docker group (for future commands)
          sudo usermod -aG docker $USER
          
          # Navigate to project directory
          cd /home/${{ secrets.EC2_USERNAME }}/adarsh-app || {
            echo "‚ùå Project directory not found. Creating it..."
            mkdir -p /home/${{ secrets.EC2_USERNAME }}/adarsh-app
            cd /home/${{ secrets.EC2_USERNAME }}/adarsh-app
          }
          
          # Clone or pull latest code
          if [ -d ".git" ]; then
            echo "üîÑ Pulling latest changes..."
            git pull origin main || git pull origin master
          else
            echo "üì• Cloning repository..."
            # Remove any existing files first (but keep hidden files like .ssh)
            find . -maxdepth 1 -name ".*" ! -name "." ! -name ".." ! -name ".ssh" -exec rm -rf {} + 2>/dev/null || true
            rm -rf * 2>/dev/null || true
            
            # Clone repository (public repo, no auth needed)
            git clone https://github.com/rushi-mereddy/adarsh-app.git . || {
              echo "‚ùå Git clone failed, trying alternative method..."
              
              # Alternative: Download as ZIP and extract
              echo "üì¶ Downloading repository as ZIP..."
              curl -L https://github.com/rushi-mereddy/adarsh-app/archive/refs/heads/main.zip -o repo.zip
              
              if command -v unzip &> /dev/null; then
                unzip -q repo.zip
                mv adarsh-app-main/* . 2>/dev/null || true
                mv adarsh-app-main/.* . 2>/dev/null || true
                rm -rf adarsh-app-main repo.zip
                echo "‚úÖ Repository downloaded and extracted successfully"
              else
                echo "‚ùå unzip not available, installing..."
                $INSTALL_CMD unzip
                unzip -q repo.zip
                mv adarsh-app-main/* . 2>/dev/null || true
                mv adarsh-app-main/.* . 2>/dev/null || true
                rm -rf adarsh-app-main repo.zip
                echo "‚úÖ Repository downloaded and extracted successfully"
              fi
            }
          fi
          
          # Verify essential files exist
          if [ ! -f "docker-compose.prod.yml" ]; then
            echo "‚ùå docker-compose.prod.yml not found!"
            echo "üìã Current directory contents:"
            ls -la
            exit 1
          else
            echo "‚úÖ docker-compose.prod.yml found"
          fi
          
          # Create .env file if it doesn't exist
          if [ ! -f ".env" ]; then
            echo "üìù Creating .env file..."
            cat > .env << 'EOF'
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          SESSION_SECRET=${{ secrets.SESSION_SECRET }}
          FLASK_ENV=production
          DOMAIN=${{ secrets.DOMAIN }}
          EOF
          fi
          
          # Create necessary directories
          mkdir -p static/uploads ssl
          chmod 755 static/uploads
          
          # Set docker-compose command (with fallback)
          if command -v docker-compose &> /dev/null; then
            DOCKER_COMPOSE="docker-compose"
          else
            # Try to find docker-compose in common locations
            for path in "/usr/local/bin/docker-compose" "/home/${{ secrets.EC2_USERNAME }}/.local/bin/docker-compose"; do
              if [ -f "$path" ]; then
                DOCKER_COMPOSE="$path"
                break
              fi
            done
            if [ -z "$DOCKER_COMPOSE" ]; then
              echo "‚ùå Docker Compose not found!"
              exit 1
            fi
          fi
          
          echo "üìç Using Docker Compose: $DOCKER_COMPOSE"
          
          # Stop existing services and free up ports
          echo "üõë Stopping existing services..."
          sudo $DOCKER_COMPOSE -f docker-compose.prod.yml down || true
          
          # Kill any processes using port 80 (quick)
          echo "üîå Freeing up port 80..."
          sudo pkill -f nginx || true
          sudo lsof -ti:80 | xargs sudo kill -9 || true
          
          # Remove old images and volumes to ensure fresh start
          echo "üßπ Cleaning up old Docker images and volumes..."
          sudo docker system prune -f || true
          sudo docker volume prune -f || true
          
          # Build and start services
          echo "üöÄ Building and starting services..."
          sudo $DOCKER_COMPOSE -f docker-compose.prod.yml build --no-cache
          sudo $DOCKER_COMPOSE -f docker-compose.prod.yml up -d
          
          # Wait for services to be ready (reduced wait time)
          echo "‚è≥ Waiting for services to start..."
          sleep 20
          
          # Quick database check (skip detailed initialization to avoid timeout)
          echo "üóÑÔ∏è Quick database check..."
          sudo $DOCKER_COMPOSE -f docker-compose.prod.yml exec -T web python -c "
          try:
              from app import app, db
              with app.app_context():
                  db.create_all()
                  print('‚úÖ Database ready!')
          except Exception as e:
              print(f'‚ö†Ô∏è Database check: {e}')
          " || echo "‚ö†Ô∏è Database initialization will complete during startup..."
          
          # Health check
          echo "üîç Performing health check..."
          sleep 10
          
          # Check if containers are running
          echo "üìä Service Status:"
          sudo $DOCKER_COMPOSE -f docker-compose.prod.yml ps
          
          # Simple connectivity test
          for i in {1..6}; do
            echo "üîç Health check attempt $i/6..."
            if curl -f -m 10 http://localhost > /dev/null 2>&1; then
              echo "‚úÖ Deployment successful! Application is running at http://$(curl -s http://checkip.amazonaws.com || echo 'localhost')"
              echo "üéâ Admin Login: admin@college.edu / admin123"
              
              # Show recent logs for confirmation
              echo "üìã Recent application logs:"
              sudo $DOCKER_COMPOSE -f docker-compose.prod.yml logs web --tail=10
              
              exit 0
            fi
            sleep 15
          done
          
          echo "‚ö†Ô∏è Health check timeout, but services may still be starting..."
          echo "üìã Final logs for debugging:"
          sudo $DOCKER_COMPOSE -f docker-compose.prod.yml logs --tail=30
          echo "‚ÑπÔ∏è If services are running, check http://$(curl -s http://checkip.amazonaws.com || echo 'YOUR-EC2-IP') in a few minutes"

  notify:
    needs: [test, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Notify deployment status
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "‚úÖ Deployment completed successfully!"
          echo "üåê Application URL: http://${{ secrets.EC2_HOST }}"
          echo "üë§ Admin Login: admin@college.edu / admin123"
        else
          echo "‚ùå Deployment failed!"
        fi
